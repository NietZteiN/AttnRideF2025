[
    {
        "code": "def add_numbers(a, b):\n    return a + b\n\nresult = add_numbers(5, 3)\nprint(result)",
        "input": "5, 3",
        "expected_output": "8",
        "description": "Simple addition function"
    },
    {
        "code": "def factorial(n):\n    if n <= 1:\n        return 1\n    return n * factorial(n-1)\n\nprint(factorial(5))",
        "input": "5",
        "expected_output": "120",
        "description": "Factorial calculation"
    },
    {
        "code": "def find_max(numbers):\n    max_num = numbers[0]\n    for num in numbers:\n        if num > max_num:\n            max_num = num\n    return max_num\n\nnumbers = [3, 7, 2, 9, 1]\nprint(find_max(numbers))",
        "input": "[3, 7, 2, 9, 1]",
        "expected_output": "9",
        "description": "Find maximum number in list"
    },
    {
        "code": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\nprint(is_prime(17))",
        "input": "17",
        "expected_output": "True",
        "description": "Check if number is prime"
    },
    {
        "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\nprint(fibonacci(6))",
        "input": "6",
        "expected_output": "8",
        "description": "Fibonacci sequence"
    },
    {
        "code": "def reverse_string(s):\n    return s[::-1]\n\nprint(reverse_string('hello'))",
        "input": "'hello'",
        "expected_output": "olleh",
        "description": "Reverse a string"
    },
    {
        "code": "def count_vowels(s):\n    vowels = 'aeiouAEIOU'\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    return count\n\nprint(count_vowels('programming'))",
        "input": "'programming'",
        "expected_output": "3",
        "description": "Count vowels in string"
    },
    {
        "code": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\nprint(bubble_sort([64, 34, 25, 12, 22]))",
        "input": "[64, 34, 25, 12, 22]",
        "expected_output": "[12, 22, 25, 34, 64]",
        "description": "Bubble sort algorithm"
    },
    {
        "code": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\nprint(binary_search([1, 3, 5, 7, 9], 5))",
        "input": "[1, 3, 5, 7, 9], 5",
        "expected_output": "2",
        "description": "Binary search algorithm"
    },
    {
        "code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nprint(gcd(48, 18))",
        "input": "48, 18",
        "expected_output": "6",
        "description": "Greatest common divisor"
    },
    {
        "code": "def is_palindrome(s):\n    s = s.lower().replace(' ', '')\n    return s == s[::-1]\n\nprint(is_palindrome('racecar'))",
        "input": "'racecar'",
        "expected_output": "True",
        "description": "Check if string is palindrome"
    },
    {
        "code": "def merge_sorted_lists(list1, list2):\n    result = []\n    i = j = 0\n    while i < len(list1) and j < len(list2):\n        if list1[i] <= list2[j]:\n            result.append(list1[i])\n            i += 1\n        else:\n            result.append(list2[j])\n            j += 1\n    result.extend(list1[i:])\n    result.extend(list2[j:])\n    return result\n\nprint(merge_sorted_lists([1, 3, 5], [2, 4, 6]))",
        "input": "[1, 3, 5], [2, 4, 6]",
        "expected_output": "[1, 2, 3, 4, 5, 6]",
        "description": "Merge two sorted lists"
    },
    {
        "code": "def power(base, exponent):\n    if exponent == 0:\n        return 1\n    elif exponent < 0:\n        return 1 / power(base, -exponent)\n    else:\n        return base * power(base, exponent - 1)\n\nprint(power(2, 3))",
        "input": "2, 3",
        "expected_output": "8",
        "description": "Calculate power recursively"
    },
    {
        "code": "def remove_duplicates(lst):\n    seen = set()\n    result = []\n    for item in lst:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return result\n\nprint(remove_duplicates([1, 2, 2, 3, 3, 3, 4]))",
        "input": "[1, 2, 2, 3, 3, 3, 4]",
        "expected_output": "[1, 2, 3, 4]",
        "description": "Remove duplicates from list"
    },
    {
        "code": "def word_count(text):\n    words = text.split()\n    return len(words)\n\nprint(word_count('The quick brown fox jumps'))",
        "input": "'The quick brown fox jumps'",
        "expected_output": "5",
        "description": "Count words in text"
    },
    {
        "code": "def linear_search(arr, target):\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1\n\nprint(linear_search([10, 20, 30, 40, 50], 30))",
        "input": "[10, 20, 30, 40, 50], 30",
        "expected_output": "2",
        "description": "Linear search algorithm"
    },
    {
        "code": "def selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min_idx = i\n        for j in range(i+1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr\n\nprint(selection_sort([64, 25, 12, 22, 11]))",
        "input": "[64, 25, 12, 22, 11]",
        "expected_output": "[11, 12, 22, 25, 64]",
        "description": "Selection sort algorithm"
    },
    {
        "code": "def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n\nprint(insertion_sort([12, 11, 13, 5, 6]))",
        "input": "[12, 11, 13, 5, 6]",
        "expected_output": "[5, 6, 11, 12, 13]",
        "description": "Insertion sort algorithm"
    },
    {
        "code": "def quick_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quick_sort(left) + middle + quick_sort(right)\n\nprint(quick_sort([3, 6, 8, 10, 1, 2, 1]))",
        "input": "[3, 6, 8, 10, 1, 2, 1]",
        "expected_output": "[1, 1, 2, 3, 6, 8, 10]",
        "description": "Quick sort algorithm"
    },
    {
        "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n\nprint(merge_sort([38, 27, 43, 3, 9, 82, 10]))",
        "input": "[38, 27, 43, 3, 9, 82, 10]",
        "expected_output": "[3, 9, 10, 27, 38, 43, 82]",
        "description": "Merge sort algorithm"
    },
    {
        "code": "def heap_sort(arr):\n    n = len(arr)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n    for i in range(n - 1, 0, -1):\n        arr[0], arr[i] = arr[i], arr[0]\n        heapify(arr, i, 0)\n    return arr\n\ndef heapify(arr, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, n, largest)\n\nprint(heap_sort([12, 11, 13, 5, 6, 7]))",
        "input": "[12, 11, 13, 5, 6, 7]",
        "expected_output": "[5, 6, 7, 11, 12, 13]",
        "description": "Heap sort algorithm"
    },
    {
        "code": "def counting_sort(arr):\n    max_val = max(arr)\n    count = [0] * (max_val + 1)\n    for num in arr:\n        count[num] += 1\n    result = []\n    for i in range(len(count)):\n        result.extend([i] * count[i])\n    return result\n\nprint(counting_sort([4, 2, 2, 8, 3, 3, 1]))",
        "input": "[4, 2, 2, 8, 3, 3, 1]",
        "expected_output": "[1, 2, 2, 3, 3, 4, 8]",
        "description": "Counting sort algorithm"
    },
    {
        "code": "def radix_sort(arr):\n    max_val = max(arr)\n    exp = 1\n    while max_val // exp > 0:\n        counting_sort_by_digit(arr, exp)\n        exp *= 10\n    return arr\n\ndef counting_sort_by_digit(arr, exp):\n    n = len(arr)\n    output = [0] * n\n    count = [0] * 10\n    for i in range(n):\n        index = arr[i] // exp\n        count[index % 10] += 1\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n    i = n - 1\n    while i >= 0:\n        index = arr[i] // exp\n        output[count[index % 10] - 1] = arr[i]\n        count[index % 10] -= 1\n        i -= 1\n    for i in range(n):\n        arr[i] = output[i]\n\nprint(radix_sort([170, 45, 75, 90, 2, 802, 24, 66]))",
        "input": "[170, 45, 75, 90, 2, 802, 24, 66]",
        "expected_output": "[2, 24, 45, 66, 75, 90, 170, 802]",
        "description": "Radix sort algorithm"
    },
    {
        "code": "def bucket_sort(arr):\n    max_val = max(arr)\n    min_val = min(arr)\n    bucket_range = (max_val - min_val) / len(arr)\n    buckets = [[] for _ in range(len(arr))]\n    for num in arr:\n        bucket_index = int((num - min_val) / bucket_range)\n        if bucket_index == len(buckets):\n            bucket_index -= 1\n        buckets[bucket_index].append(num)\n    result = []\n    for bucket in buckets:\n        bucket.sort()\n        result.extend(bucket)\n    return result\n\nprint(bucket_sort([0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51]))",
        "input": "[0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51]",
        "expected_output": "[0.32, 0.33, 0.37, 0.42, 0.47, 0.51, 0.52]",
        "description": "Bucket sort algorithm"
    },
    {
        "code": "def depth_first_search(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    result = [start]\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            result.extend(depth_first_search(graph, neighbor, visited))\n    return result\n\ngraph = {'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F'], 'D': [], 'E': ['F'], 'F': []}\nprint(depth_first_search(graph, 'A'))",
        "input": "graph, 'A'",
        "expected_output": "['A', 'B', 'D', 'E', 'F', 'C']",
        "description": "Depth-first search algorithm"
    },
    {
        "code": "def breadth_first_search(graph, start):\n    visited = set()\n    queue = [start]\n    visited.add(start)\n    result = []\n    while queue:\n        vertex = queue.pop(0)\n        result.append(vertex)\n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return result\n\ngraph = {'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F'], 'D': [], 'E': ['F'], 'F': []}\nprint(breadth_first_search(graph, 'A'))",
        "input": "graph, 'A'",
        "expected_output": "['A', 'B', 'C', 'D', 'E', 'F']",
        "description": "Breadth-first search algorithm"
    },
    {
        "code": "def dijkstra(graph, start):\n    distances = {vertex: float('infinity') for vertex in graph}\n    distances[start] = 0\n    unvisited = set(graph.keys())\n    while unvisited:\n        current = min(unvisited, key=lambda vertex: distances[vertex])\n        unvisited.remove(current)\n        for neighbor, weight in graph[current].items():\n            distance = distances[current] + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n    return distances\n\ngraph = {'A': {'B': 1, 'C': 4}, 'B': {'A': 1, 'C': 2, 'D': 5}, 'C': {'A': 4, 'B': 2, 'D': 1}, 'D': {'B': 5, 'C': 1}}\nprint(dijkstra(graph, 'A'))",
        "input": "graph, 'A'",
        "expected_output": "{'A': 0, 'B': 1, 'C': 3, 'D': 4}",
        "description": "Dijkstra's shortest path algorithm"
    },
    {
        "code": "def floyd_warshall(graph):\n    n = len(graph)\n    dist = [[float('inf')] * n for _ in range(n)]\n    for i in range(n):\n        dist[i][i] = 0\n    for u in range(n):\n        for v, weight in graph[u].items():\n            dist[u][v] = weight\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    return dist\n\ngraph = {0: {1: 3, 2: 6}, 1: {0: 3, 2: 2}, 2: {0: 6, 1: 2}}\nprint(floyd_warshall(graph))",
        "input": "graph",
        "expected_output": "[[0, 3, 5], [3, 0, 2], [5, 2, 0]]",
        "description": "Floyd-Warshall all-pairs shortest path"
    },
    {
        "code": "def knapsack(items, capacity):\n    n = len(items)\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        weight, value = items[i-1]\n        for w in range(capacity + 1):\n            if weight <= w:\n                dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value)\n            else:\n                dp[i][w] = dp[i-1][w]\n    return dp[n][capacity]\n\nitems = [(10, 60), (20, 100), (30, 120)]\nprint(knapsack(items, 50))",
        "input": "items, 50",
        "expected_output": "220",
        "description": "0/1 Knapsack problem"
    },
    {
        "code": "def longest_common_subsequence(text1, text2):\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i-1] == text2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    return dp[m][n]\n\nprint(longest_common_subsequence('abcde', 'ace'))",
        "input": "'abcde', 'ace'",
        "expected_output": "3",
        "description": "Longest common subsequence"
    },
    {
        "code": "def edit_distance(str1, str2):\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i-1] == str2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    return dp[m][n]\n\nprint(edit_distance('kitten', 'sitting'))",
        "input": "'kitten', 'sitting'",
        "expected_output": "3",
        "description": "Edit distance (Levenshtein distance)"
    },
    {
        "code": "def coin_change(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount] if dp[amount] != float('inf') else -1\n\nprint(coin_change([1, 3, 4], 6))",
        "input": "[1, 3, 4], 6",
        "expected_output": "2",
        "description": "Coin change problem"
    },
    {
        "code": "def longest_increasing_subsequence(nums):\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\nprint(longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]))",
        "input": "[10, 9, 2, 5, 3, 7, 101, 18]",
        "expected_output": "4",
        "description": "Longest increasing subsequence"
    },
    {
        "code": "def matrix_chain_multiplication(dims):\n    n = len(dims) - 1\n    dp = [[0] * n for _ in range(n)]\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = float('inf')\n            for k in range(i, j):\n                cost = dp[i][k] + dp[k+1][j] + dims[i] * dims[k+1] * dims[j+1]\n                dp[i][j] = min(dp[i][j], cost)\n    return dp[0][n-1]\n\nprint(matrix_chain_multiplication([1, 2, 3, 4]))",
        "input": "[1, 2, 3, 4]",
        "expected_output": "18",
        "description": "Matrix chain multiplication optimization"
    },
    {
        "code": "def rod_cutting(prices, length):\n    dp = [0] * (length + 1)\n    for i in range(1, length + 1):\n        for j in range(i):\n            dp[i] = max(dp[i], prices[j] + dp[i - j - 1])\n    return dp[length]\n\nprint(rod_cutting([1, 5, 8, 9, 10, 17, 17, 20], 8))",
        "input": "[1, 5, 8, 9, 10, 17, 17, 20], 8",
        "expected_output": "22",
        "description": "Rod cutting problem"
    },
    {
        "code": "def subset_sum(nums, target):\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for num in nums:\n        for i in range(target, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n    return dp[target]\n\nprint(subset_sum([3, 34, 4, 12, 5, 2], 9))",
        "input": "[3, 34, 4, 12, 5, 2], 9",
        "expected_output": "True",
        "description": "Subset sum problem"
    },
    {
        "code": "def partition_equal_subset_sum(nums):\n    total = sum(nums)\n    if total % 2 != 0:\n        return False\n    target = total // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for num in nums:\n        for i in range(target, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n    return dp[target]\n\nprint(partition_equal_subset_sum([1, 5, 11, 5]))",
        "input": "[1, 5, 11, 5]",
        "expected_output": "True",
        "description": "Partition equal subset sum"
    },
    {
        "code": "def word_break(s, word_dict):\n    word_set = set(word_dict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    return dp[len(s)]\n\nprint(word_break('leetcode', ['leet', 'code']))",
        "input": "'leetcode', ['leet', 'code']",
        "expected_output": "True",
        "description": "Word break problem"
    },
    {
        "code": "def unique_paths(m, n):\n    dp = [[1] * n for _ in range(m)]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[m-1][n-1]\n\nprint(unique_paths(3, 7))",
        "input": "3, 7",
        "expected_output": "28",
        "description": "Unique paths in grid"
    },
    {
        "code": "def unique_paths_with_obstacles(obstacle_grid):\n    m, n = len(obstacle_grid), len(obstacle_grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1 if obstacle_grid[0][0] == 0 else 0\n    for i in range(m):\n        for j in range(n):\n            if obstacle_grid[i][j] == 1:\n                dp[i][j] = 0\n            else:\n                if i > 0:\n                    dp[i][j] += dp[i-1][j]\n                if j > 0:\n                    dp[i][j] += dp[i][j-1]\n    return dp[m-1][n-1]\n\nprint(unique_paths_with_obstacles([[0,0,0],[0,1,0],[0,0,0]]))",
        "input": "[[0,0,0],[0,1,0],[0,0,0]]",
        "expected_output": "2",
        "description": "Unique paths with obstacles"
    },
    {
        "code": "def minimum_path_sum(grid):\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[m-1][n-1]\n\nprint(minimum_path_sum([[1,3,1],[1,5,1],[4,2,1]]))",
        "input": "[[1,3,1],[1,5,1],[4,2,1]]",
        "expected_output": "7",
        "description": "Minimum path sum in grid"
    },
    {
        "code": "def climb_stairs(n):\n    if n <= 2:\n        return n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]\n\nprint(climb_stairs(5))",
        "input": "5",
        "expected_output": "8",
        "description": "Climbing stairs problem"
    },
    {
        "code": "def house_robber(nums):\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    return dp[-1]\n\nprint(house_robber([2, 7, 9, 3, 1]))",
        "input": "[2, 7, 9, 3, 1]",
        "expected_output": "12",
        "description": "House robber problem"
    },
    {
        "code": "def longest_palindromic_substring(s):\n    if not s:\n        return ''\n    start = 0\n    max_len = 1\n    for i in range(len(s)):\n        # Check for odd length palindromes\n        left, right = i, i\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            if right - left + 1 > max_len:\n                start = left\n                max_len = right - left + 1\n            left -= 1\n            right += 1\n        # Check for even length palindromes\n        left, right = i, i + 1\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            if right - left + 1 > max_len:\n                start = left\n                max_len = right - left + 1\n            left -= 1\n            right += 1\n    return s[start:start + max_len]\n\nprint(longest_palindromic_substring('babad'))",
        "input": "'babad'",
        "expected_output": "bab",
        "description": "Longest palindromic substring"
    },
    {
        "code": "def longest_common_prefix(strs):\n    if not strs:\n        return ''\n    prefix = strs[0]\n    for i in range(1, len(strs)):\n        while not strs[i].startswith(prefix):\n            prefix = prefix[:-1]\n            if not prefix:\n                return ''\n    return prefix\n\nprint(longest_common_prefix(['flower', 'flow', 'flight']))",
        "input": "['flower', 'flow', 'flight']",
        "expected_output": "fl",
        "description": "Longest common prefix"
    },
    {
        "code": "def valid_parentheses(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            stack.append(char)\n    return not stack\n\nprint(valid_parentheses('()[]{}'))",
        "input": "'()[]{}'",
        "expected_output": "True",
        "description": "Valid parentheses"
    },
    {
        "code": "def generate_parentheses(n):\n    result = []\n    def backtrack(current, open_count, close_count):\n        if len(current) == 2 * n:\n            result.append(current)\n            return\n        if open_count < n:\n            backtrack(current + '(', open_count + 1, close_count)\n        if close_count < open_count:\n            backtrack(current + ')', open_count, close_count + 1)\n    backtrack('', 0, 0)\n    return result\n\nprint(generate_parentheses(3))",
        "input": "3",
        "expected_output": "['((()))', '(()())', '(())()', '()(())', '()()()']",
        "description": "Generate parentheses"
    },
    {
        "code": "def combination_sum(candidates, target):\n    result = []\n    def backtrack(remaining, current_combo, start):\n        if remaining == 0:\n            result.append(current_combo[:])\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] <= remaining:\n                current_combo.append(candidates[i])\n                backtrack(remaining - candidates[i], current_combo, i)\n                current_combo.pop()\n    backtrack(target, [], 0)\n    return result\n\nprint(combination_sum([2, 3, 6, 7], 7))",
        "input": "[2, 3, 6, 7], 7",
        "expected_output": "[[2, 2, 3], [7]]",
        "description": "Combination sum"
    },
    {
        "code": "def permutations(nums):\n    result = []\n    def backtrack(current):\n        if len(current) == len(nums):\n            result.append(current[:])\n            return\n        for num in nums:\n            if num not in current:\n                current.append(num)\n                backtrack(current)\n                current.pop()\n    backtrack([])\n    return result\n\nprint(permutations([1, 2, 3]))",
        "input": "[1, 2, 3]",
        "expected_output": "[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]",
        "description": "Permutations"
    },
    {
        "code": "def subsets(nums):\n    result = []\n    def backtrack(start, current):\n        result.append(current[:])\n        for i in range(start, len(nums)):\n            current.append(nums[i])\n            backtrack(i + 1, current)\n            current.pop()\n    backtrack(0, [])\n    return result\n\nprint(subsets([1, 2, 3]))",
        "input": "[1, 2, 3]",
        "expected_output": "[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]",
        "description": "Subsets generation"
    },
    {
        "code": "def n_queens(n):\n    result = []\n    board = [['.' for _ in range(n)] for _ in range(n)]\n    def is_safe(row, col):\n        for i in range(row):\n            if board[i][col] == 'Q':\n                return False\n        for i, j in zip(range(row-1, -1, -1), range(col-1, -1, -1)):\n            if board[i][j] == 'Q':\n                return False\n        for i, j in zip(range(row-1, -1, -1), range(col+1, n)):\n            if board[i][j] == 'Q':\n                return False\n        return True\n    def backtrack(row):\n        if row == n:\n            result.append([''.join(row) for row in board])\n            return\n        for col in range(n):\n            if is_safe(row, col):\n                board[row][col] = 'Q'\n                backtrack(row + 1)\n                board[row][col] = '.'\n    backtrack(0)\n    return len(result)\n\nprint(n_queens(4))",
        "input": "4",
        "expected_output": "2",
        "description": "N-Queens problem"
    },
    {
        "code": "def sudoku_solver(board):\n    def is_valid(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num:\n                return False\n        start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n        for i in range(3):\n            for j in range(3):\n                if board[start_row + i][start_col + j] == num:\n                    return False\n        return True\n    def solve(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    for num in '123456789':\n                        if is_valid(board, i, j, num):\n                            board[i][j] = num\n                            if solve(board):\n                                return True\n                            board[i][j] = '.'\n                    return False\n        return True\n    solve(board)\n    return board\n\nboard = [['5','3','.','.','7','.','.','.','.'],['6','.','.','1','9','5','.','.','.'],['.','9','8','.','.','.','.','6','.'],['8','.','.','.','6','.','.','.','3'],['4','.','.','8','.','3','.','.','1'],['7','.','.','.','2','.','.','.','6'],['.','6','.','.','.','.','2','8','.'],['.','.','.','4','1','9','.','.','5'],['.','.','.','.','8','.','.','7','9']]\nprint(sudoku_solver(board))",
        "input": "board",
        "expected_output": "[['5', '3', '4', '6', '7', '8', '9', '1', '2'], ['6', '7', '2', '1', '9', '5', '3', '4', '8'], ['1', '9', '8', '3', '4', '2', '5', '6', '7'], ['8', '5', '9', '7', '6', '1', '4', '2', '3'], ['4', '2', '6', '8', '5', '3', '7', '9', '1'], ['7', '1', '3', '9', '2', '4', '8', '5', '6'], ['9', '6', '1', '5', '3', '7', '2', '8', '4'], ['2', '8', '7', '4', '1', '9', '6', '3', '5'], ['3', '4', '5', '2', '8', '6', '1', '7', '9']]",
        "description": "Sudoku solver"
    }
]